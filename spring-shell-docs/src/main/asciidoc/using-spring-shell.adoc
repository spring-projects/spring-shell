:starter-artifactId: spring-shell-starter

== Using Spring Shell

This section describes how to use Spring Shell.

=== Getting Started

To see what Spring Shell has to offer, we can write a trivial shell application that
has a simple command to add two numbers.

==== Writing a Simple Boot Application

Starting with version 2, Spring Shell has been rewritten from the ground up with various
enhancements in mind, one of which is easy integration with Spring Boot, although it is
not a strong requirement.
For the purpose of this tutorial, we create a simple Boot application by
using https://start.spring.io. This minimal application depends only on `spring-boot-starter`
and configures the `spring-boot-maven-plugin` to generate an executable Ã¼ber-jar:

====
[source, xml]
----
...
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
    </dependency>
    ...
</dependencies>
----
====

==== Adding a Dependency on Spring Shell

The easiest way to get going with Spring Shell is to depend on the `{starter-artifactId}` artifact.
This comes with everything one needs to use Spring Shell and plays nicely with Boot,
configuring only the necessary beans as needed:

====
[source, xml, subs=attributes+]
----
...
<dependency>
    <groupId>org.springframework.shell</groupId>
    <artifactId>{starter-artifactId}</artifactId>
    <version>{project-version}</version>
</dependency>
...
----
====

CAUTION: Given that Spring Shell starts the REPL by virtue of this dependency being present,
you need to either skip tests when you build (`-DskipTests`) throughout this tutorial or remove the sample integration test
that was generated by https://start.spring.io. If you do not remove it, the integration test creates
the Spring `ApplicationContext` and, depending on your build tool, stays stuck in the eval loop or crashes with a NPE.

[[your-first-command]]
==== Your First Command

Now we can add our first command. To do so, create a new class (named whatever you want) and
annotate it with `@ShellComponent` (a variation of `@Component` that is used to restrict
the set of classes that are scanned for candidate commands).

Then create an `add` method that takes two ints (`a` and `b`) and returns their sum. Annotate it
with `@ShellMethod` and provide a description of the command in the annotation (the only piece of
information that is required):

====
[source, java]
----
package com.example.demo;

import org.springframework.shell.standard.ShellMethod;
import org.springframework.shell.standard.ShellComponent;

@ShellComponent
public class MyCommands {

    @ShellMethod("Add two integers together.")
    public int add(int a, int b) {
        return a + b;
    }
}
----
====

==== Trying the Application

To build the application and run the generated jar, run the following command:

====
[source, bash]
----
./mvnw clean install -DskipTests
[...]

java -jar target/demo-0.0.1-SNAPSHOT.jar
----
====

You are greeted by the following screen (the banner comes from Spring Boot and can be
https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-banner[customized]:

====
[source]
----

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v1.5.6.RELEASE)

shell:>
----
====

A yellow `shell:>` prompt invites you to type commands. Type `add 1 2`, press `ENTER`, and admire the magic:

====
[source, bash]
----
shell:>add 1 2
3
----
====

Try to play with the shell (hint: there is a `help` command). When you are done, type `exit` and press `ENTER`.

The rest of this document delves deeper into the whole Spring Shell programming model.

=== Writing Your Own Commands

The way Spring Shell decides to turn a method into an actual shell command is entirely pluggable
(see <<extending-spring-shell>>). However, as of Spring Shell 2.x, the recommended way to write commands
is to use the new API described in this section (the standard API).

When you use the standard API, methods on beans are turned into executable commands, provided that:

* The bean class bears the `@ShellComponent` annotation. This is used to restrict the set of beans that
are considered.
* The method bears the `@ShellMethod` annotation.

[TIP]
====
The `@ShellComponent` is a stereotype annotation that is itself meta-annotated with `@Component`. As a result, you
can used it in addition to the filtering mechanism to declare beans (for example, by using `@ComponentScan`).

You can customize the name of the created bean by using the `value` attribute of the annotation.
====

[[documenting-the-command]]
==== Documenting the Command

The only required attribute of the `@ShellMethod` annotation is its `value` attribute, which should have
a short, one-sentence, description of what the command does. This lets your users
get consistent help about your commands without having to leave the shell (see <<help-command>>).

NOTE: The description of your command should be short -- no more than one or two sentences. For better consistency, it
should starts with a capital letter and end with a period.

==== Customizing the Command Name(s)

By default, there is no need to specify the key for your command (that is, the word(s) that should be used
to invoke it in the shell). The name of the method is used as the command key, turning camelCase names into
dashed, gnu-style, names (that is, `sayHello()` becomes `say-hello`).

You can, however, explicitly set the command key, by using the `key` attribute of the annotation:

====
[source, java]
----
	@ShellMethod(value = "Add numbers.", key = "sum")
	public int add(int a, int b) {
		return a + b;
	}

----
====

NOTE: The `key` attribute accepts multiple values.
If you set multiple keys for a single method, the command is registered with those different aliases.

TIP: The command key can contain pretty much any character, including spaces. When coming up with names though,
keep in mind that consistency is often appreciated by users (that is, you should avoid mixing dashed-names with spaced names and other inconsistencies).


=== Invoking your Commands

This section addresses how you can control the way in which your commands are invoked.

==== By Name Versus Positional Parameters

As seen <<documenting-the-command,earlier>>, decorating a method with `@ShellMethod` is the sole requirement for creating a command.

The user can set the value of all the method parameters in either of two ways:

* By using a parameter key (for example, `--arg value`). This approach is called "`by name parameters.`"
* Without a key, by setting parameter values in the order in which they appear in the method signature (called "`positional parameters`").

These two approaches can be mixed and matched, with named parameters always taking precedence (as they are less
prone to ambiguity). Consider the following command definition:

====
[source, java]
----
	@ShellMethod("Display stuff.")
	public String echo(int a, int b, int c) {
		return String.format("You said a=%d, b=%d, c=%d", a, b, c);
	}
----
====

Given the preceding command definiton, the following invocations are all equivalent, as shown in the output:

====
[source, bash]
----
shell:>echo 1 2 3               <1>
You said a=1, b=2, c=3

shell:>echo --a 1 --b 2 --c 3   <2>
You said a=1, b=2, c=3

shell:>echo --b 2 --c 3 --a 1   <3>
You said a=1, b=2, c=3

shell:>echo --a 1 2 3           <4>
You said a=1, b=2, c=3

shell:>echo 1 --c 3 2           <5>
You said a=1, b=2, c=3
----
<1> This uses positional parameters.
<2> This is an example of full by-name parameters.
<3> By-name parameters can be reordered as desired.
<4> You can use a mix of the two approaches.
<5> The non by-name parameters are resolved in the order in which they appear.
====

===== Customizing the Named Parameter Keys

As seen <<your-first-command,earlier>>, the default strategy for deriving the key for a named parameter is to use the Java
name of the method signature and prefix it with two dashes (`--`). You can customize this in two ways:

* Use the `prefix()` attribute of the `@ShellMethod` annotation to change the default prefix for the whole method.
* Annotate the parameter with the `@ShellOption` annotation to override the entire key in a per-parameter fashion.

Consider the following example:

====
[source, java]
----
	@ShellMethod(value = "Display stuff.", prefix="-")
	public String echo(int a, int b, @ShellOption("--third") int c) {
		return String.format("You said a=%d, b=%d, c=%d", a, b, c);
	}
----
====

For such a setup, the possible parameter keys are `-a`, `-b` and `--third`.

[TIP]
=====
You can specify several keys for a single parameter. If you do so, these keys are mutually exclusive (only one of them can be used) ways
to specify the same parameter. The following example shows the signature of the
built-in <<help-command,`help`>> command:

====
[source, java]
----
	@ShellMethod("Describe a command.")
	public String help(@ShellOption({"-C", "--command"}) String command) {
		...
	}
----
====
=====

[[optional-parameters-default-values]]
==== Optional Parameters and Default Values

Spring Shell provides the ability to give parameters default values, which lets users omit
those parameters. Consider the following command definition:

====
[source, java]
----
	@ShellMethod("Say hello.")
	public String greet(@ShellOption(defaultValue="World") String who) {
		return "Hello " + who;
	}
----
====

With the preceding definition, the `greet` command can still be invoked as `greet Mother` (or `greet --who Mother`), but the following
is also possible:

====
[source]
----
shell:>greet
Hello World
----
====

==== Parameter Arity
Up to now, it has always been assumed that each parameter maps to a single word entered by the user.
Situations may arise, though, when a parameter value should be multi-valued. This is driven by the `arity()`
attribute of the `@ShellOption` annotation. You can use a collection or array for the parameter type and specify how
many values are expected:

====
[source, java]
----
	@ShellMethod("Add Numbers.")
	public float add(@ShellOption(arity=3) float[] numbers) {
		return numbers[0] + numbers[1] + numbers[2];
	}
----
====

The users can then invoke the command by using any of the following syntax:

====
[source]
----
shell:>add 1 2 3.3
6.3
shell:>add --numbers 1 2 3.3
6.3
----
====

[WARNING]
=====
When using the _by-name_ parameter approach, the key should *not* be repeated. The following does *not* work:

====
[source]
----
shell:>add --numbers 1 --numbers 2 --numbers 3.3
----
====
=====

===== Infinite Arity

TO BE IMPLEMENTED

===== Special Handling of Boolean Parameters

When it comes to parameter arity, one kind of parameter receives a special treatment by default, as
is often the case in command-line utilities.
Boolean (that is, `boolean` as well as `java.lang.Boolean`) parameters behave like they have an `arity()` of `0` by default, allowing users to set their values by using a "`flag`" approach.
Consider the following command definition:

====
[source, java]
----
	@ShellMethod("Terminate the system.")
	public String shutdown(boolean force) {
		return "You said " + force;
	}
----
====

This preceding command definition allows the following invocations:

====
[source]
----
shell:>shutdown
You said false
shell:>shutdown --force
You said true
----
====

TIP: This special treatment plays well with the <<optional-parameters-default-values,default value>> specification. Although the default
for boolean parameters is to have their default value be `false`, you can specify otherwise (that is,
`@ShellOption(defaultValue="true")`), and the behavior is inverted (that is, not specifying the parameter
results in the value being `true`, and specifying the flag results in the value being `false`)

[WARNING]
=====
Having this behavior of implicit `arity()=0` prevents the user from specifying a value (for example, `shutdown --force true`).
If you would like to allow this behavior (and forego the flag approach), then force an arity of `1` by using the annotation as follows:

====
[source, java]
----
	@ShellMethod("Terminate the system.")
	public String shutdown(@ShellOption(arity=1, defaultValue="false") boolean force) {
		return "You said " + force;
	}
----
====
=====

[[quotes-handling]]
==== Quotes Handling

Spring Shell takes user input and tokenizes it into words, splitting on space characters.
If the user wants to provide a parameter value that contains spaces, that value needs to be quoted.
Both single (`'`) and double (`"`) quotes are supported, and those quotes are not part of the value:
Consider the following command definition:

====
[source, java]
----
	@ShellMethod("Prints what has been entered.")
	public String echo(String what) {
		return "You said " + what;
	}
----
====

The following commands all invoke the preceding command definition:

====
[source]
----
shell:>echo Hello
You said Hello
shell:>echo 'Hello'
You said Hello
shell:>echo 'Hello World'
You said Hello World
shell:>echo "Hello World"
You said Hello World
----
====

Supporting both single and double quotes lets the user embed one type of quotes into
a value:

====
[source]
----
shell:>echo "I'm here!"
You said I'm here!
shell:>echo 'He said "Hi!"'
You said He said "Hi!"
----
====

That way, the user can use a single quote as an apostrophe in a message.

Should the user need to embed the same kind of quote that was used to quote the whole parameter,
the escape sequence uses the backslash (`\`) character:

====
[source]
----
shell:>echo 'I\'m here!'
You said I'm here!
shell:>echo "He said \"Hi!\""
You said He said "Hi!"
shell:>echo I\'m here!
You said I'm here!
----
====

It is also possible to escape space characters when not using enclosing quotes:

====
[source]
----
shell:>echo This\ is\ a\ single\ value
You said This is a single value
----
====

[[interacting-with-the-shell]]
==== Interacting with the Shell

The Spring Shell project builds on top of the https://github.com/jline/jline3[JLine] library and, as a result, brings
a lot of nice interactive features, some of which are detailed in this section.

First and foremost, Spring Shell supports tab completion almost everywhere possible. So, if there
is an `echo` command and the user types `ec` and presses `TAB`, `echo` appears.
Should there be several commands that start with `ec`, then the user is prompted to choose (using `TAB` or
`Shift + TAB` to navigate and `ENTER` to select.)

But completion does not stop at command keys. It also works for parameter keys (`--arg`) and even
parameter values, if the application developer registered the appropriate beans (see <<providing-tab-completion>>).

Another nice feature of Spring Shell applications is support for line continuation. If a command and its parameters
is too long and does not fit nicely on the screen, a user can chunk it by ending a line with a backslash (`\`) character,
pressing `ENTER`, and continuing on the next line. Upon submission of the whole command, this is
parsed as if the user entered a single space on line breaks. The following listing shows an example of this behavior:

====
[source]
----
shell:>register module --type source --name foo  \ <1>
> --uri file:///tmp/bar
Successfully registered module 'source:foo'
----
<1> command continues on next line
====

Line continuation also automatically triggers if the user has opened a quote (see <<quotes-handling>>)
and presses `ENTER` while still in the quotes:

====
[source]
----
shell:>echo "Hello <1>
dquote> World"
You said Hello World
----
<1> The user pressed `ENTER` here.
====

Finally, Spring Shell applications benefit from a lot of keyboard shortcuts (borrowed from Emacs) with which you may already be familiar from
working with your regular OS Shell. Notable shortcuts include `Ctrl+r` to perform
a reverse search, `Ctrl+a`] and `Ctrl+e` to move to the beginning and the end of the current line (respectively), and `Esc f` and
`Esc b` to move forward or backward (respectively) one word at a time.

[[providing-tab-completion]]
===== Providing TAB Completion Proposals

TBD

[[validating-command-arguments]]
=== Validating Command Arguments

Spring Shell integrates with the https://beanvalidation.org/[Bean Validation API] to support
automatic and self-documenting constraints on command parameters.

Annotations found on command parameters as well as annotations at the method level are
honored and trigger validation prior to the command executing. Consider the following command:

====
[source, java]
----
	@ShellMethod("Change password.")
	public String changePassword(@Size(min = 8, max = 40) String password) {
		return "Password successfully set to " + password;
	}
----
====

From the preceding example, you get the following behavior for free:

====
----
shell:>change-password hello
The following constraints were not met:
	--password string : size must be between 8 and 40 (You passed 'hello')
----
====

.Applies to All Command Implementations
NOTE: It is important to note that bean validation applies to all command implementations, whether
they use the "standard" API or any other API, through the use of an adapter (see <<support-for-shell-1-and-jcommander,Supporting Other APIs>>)

[[dynamic-command-availability]]
=== Dynamic Command Availability

Registered commands do not always make sense, due to the internal state of the application.
For example, there may be a `download` command, but it only works once the user has used `connect` on a remote
server. Now, if the user tries to use the `download` command, the shell should gracefully explain that
the command exist but that it is not available at the time.
Spring Shell lets you do that, even letting you provide a short explanation of the reason for
the command not being available.

There are three possible ways for a command to indicate availability.
They all leverage a no-arg method that returns an instance of `Availability`.
Consider the following example:

====
[source, java]
----
@ShellComponent
public class MyCommands {

    private boolean connected;

    @ShellMethod("Connect to the server.")
    public void connect(String user, String password) {
        [...]
        connected = true;
    }

    @ShellMethod("Download the nuclear codes.")
    public void download() {
        [...]
    }

    public Availability downloadAvailability() {
        return connected
            ? Availability.available()
            : Availability.unavailable("you are not connected");
    }
}
----
====

The `connect` method is used to connect to the server (details omitted), altering the state
of the command through the `connected` boolean when done.
The `download` command as marked as unavailable until the user has connected, thanks to the presence
of a method named exactly as the `download` command method with the `Availability` suffix in its name.
The method returns an instance of `Availability`, constructed with one of the two factory methods.
If the command is not available, an explanation has to be provided.
Now, if the user tries to invoke the command while not being connected, here is what happens:

====
[source]
----
shell:>download
Command 'download' exists but is not currently available because you are not connected.
Details of the error have been omitted. You can use the stacktrace command to print the full stacktrace.
----
====

Information about currently unavailable commands is also used in the integrated help. See <<help-command>>.

[TIP]
====
The reason provided when the command is not available should read nicely if appended after "`Because`".

You should not start the sentence with a capital or add a final period
====

If naming the availability method after the name of the command method does not suit you, you
can provide an explicit name by using the `@ShellMethodAvailability` annotation:

====
[source, java]
----
    @ShellMethod("Download the nuclear codes.")
    @ShellMethodAvailability("availabilityCheck") // <1>
    public void download() {
        [...]
    }

    public Availability availabilityCheck() { // <1>
        return connected
            ? Availability.available()
            : Availability.unavailable("you are not connected");
    }
----
<1> the names have to match
====

Lastly, it is often the case that several commands in the same class share the same internal state and, thus,
should all be available or unavailable as a group. Instead of having to stick the `@ShellMethodAvailability`
on all command methods, Spring Shell lets you flip things around and put the `@ShellMethodAvailabilty`
annotation on the availability method, specifying the names of the commands that it controls:

====
[source, java]
----
    @ShellMethod("Download the nuclear codes.")
    public void download() {
        [...]
    }

    @ShellMethod("Disconnect from the server.")
    public void disconnect() {
        [...]
    }

    @ShellMethodAvailability({"download", "disconnect"})
    public Availability availabilityCheck() {
        return connected
            ? Availability.available()
            : Availability.unavailable("you are not connected");
    }
----
====

[TIP]
=====
The default value for the `@ShellMethodAvailability.value()` attribute is `*`. This special
wildcard matches all command names. This makes it easy to turn all commands of a single class on or off
with a single availability method:

====
[source,java]
----
@ShellComponent
public class Toggles {
  @ShellMethodAvailability
  public Availability availabilityOnWeekdays() {
    return Calendar.getInstance().get(DAY_OF_WEEK) == SUNDAY
      ? Availability.available()
      : Availability.unavailable("today is not Sunday");
  }

  @ShellMethod
  public void foo() {}

  @ShellMethod
  public void bar() {}
}
----
====
=====

TIP: Spring Shell does not impose many constraints on how to write commands and how to organize classes.
However, it is often good practice to put related commands in the same class, and the availability indicators
can benefit from that.

[[organizing-commands]]
=== Organizing Commands

When your shell starts to provide a lot of functionality, you may end up
with a lot of commands, which could be confusing for your users. By typing `help`,
they would see a daunting list of commands, organized in alphabetical order,
which may not always make sense.

To alleviate this possible confusion, Spring Shell provides the ability to group commands together,
with reasonable defaults. Related commands would then end up in the same group (for example, `User Management Commands`)
and be displayed together in the help screen and other places.

By default, commands are grouped according to the class they are implemented in,
turning the camel case class name into separate words (so `URLRelatedCommands` becomes `URL Related Commands`).
This is a very sensible default, as related commands are often already in the class anyway,
because they need to use the same collaborating objects.

If, however, this behavior does not suit you, you can override the group for a
command in the following ways, in order of priority:

. Specifying a `group()` in the `@ShellMethod` annotation.
. Placing a `@ShellCommandGroup` on the class in which the command is defined. This applies
the group for all commands defined in that class (unless overridden, as explained earlier).
. Placing a `@ShellCommandGroup` on the package (through `package-info.java`)
in which the command is defined. This applies to all the commands defined in the
package (unless overridden at the method or class level, as explained earlier)

The following listing shows an example:

====
[source,java]
----
public class UserCommands {
    @ShellMethod(value = "This command ends up in the 'User Commands' group")
    public void foo() {}

    @ShellMethod(value = "This command ends up in the 'Other Commands' group",
    	group = "Other Commands")
    public void bar() {}
}

...

@ShellCommandGroup("Other Commands")
public class SomeCommands {
	@ShellMethod(value = "This one is in 'Other Commands'")
	public void wizz() {}

	@ShellMethod(value = "And this one is 'Yet Another Group'",
		group = "Yet Another Group")
	public void last() {}
}
----
====

[[built-in-commands]]
=== Built-In Commands

Any application built by using the `{starter-artifactId}` artifact
(or, to be more precise, the `spring-shell-standard-commands` dependency) comes with a set of built-in commands.
You can override or disable these commands individually (see <<overriding-or-disabling-built-in-commands>>).
However, if they are not overridden or disabled, this section describes their behavior.

[[help-command]]
==== Integrated Documentation with the `help` Command

Running a shell application often implies that the user is in a graphically limited
environment. Also, while we are nearly always connected in the era of mobile phones,
accessing a web browser or any other rich UI application (such as a PDF viewer) may not always
be possible. This is why it is important that the shell commands are correctly self documented, and this is where the `help`
command comes in.

Typing `help` + `ENTER` lists all the commands known to the shell (including <<dynamic-command-availability,unavailable>> commands)
and a short description of what they do, similar to the following:

====
[source]
----
shell:>help
AVAILABLE COMMANDS
        add: Add numbers together.
      * authenticate: Authenticate with the system.
      * blow-up: Blow Everything up.
        clear: Clear the shell screen.
        connect: Connect to the system
        disconnect: Disconnect from the system.
        exit, quit: Exit the shell.
        help: Display help about available commands.
        register module: Register a new module.
        script: Read and execute commands from a file.
        stacktrace: Display the full stacktrace of the last error.

Commands marked with (*) are currently unavailable.
Type `help <command>` to learn more.
----
====

Typing `help <command>` shows more detailed information about a command, including the available parameters, their
type, whether they are mandatory or not, and other details.

The follwoing listing shows the `help` command applied to itself:

====
----
shell:>help help


NAME
	help - Display help about available commands.

SYNOPSYS
	help [[-C] string]

OPTIONS
	-C or --command  string
		The command to obtain help for.  [Optional, default = <none>]
----
====

==== Clearing the Screen
The `clear` command does what you would expect and clears the screen, resetting the prompt
in the top left corner.

==== Exiting the Shell

The `quit` command (also aliased as `exit`) requests the shell to quit, gracefully
closing the Spring application context. If not overridden, a JLine `History` bean writes a history of all
commands to disk, so that they are available again (see <<interacting-with-the-shell>>) on the next launch.

==== Displaying Details about an Error

When an exception occurs inside command code, it is caught by the shell and a simple, one-line message is displayed
so as not to overflow the user with too much information.
There are cases though when understanding what exactly happened is important (especially if the exception has a nested cause).

To this end, Spring Shell remembers the last exception that occurred, and the user can later use the `stacktrace`
command to print all the details on the console.

[[script-command]]
==== Running a Batch of Commands

The `script` command accepts a local file as an argument and replays commands found there, one at a time.

Reading from the file behaves exactly like inside the interactive shell, so lines starting with `//` are considered
to be comments and are ignored, while lines ending with `\` trigger line continuation.


=== Customizing the Shell

[[overriding-or-disabling-built-in-commands]]
==== Overriding or Disabling Built-In Commands

Spring Shell provides <<built-in-commands,Built-in commands>> to let people achieve everyday tasks that many if not
all shell applications need. If you are not happy with the way they behave, though, you can disable or override them, as explained in this section.

[TIP]
.Disabling all Built-in Commands
=====
If you do not need built-in commands at all, there is an easy way to "`disable`" them: don't include them.
Either use a maven exclusion on `spring-shell-standard-commands` or, if you are selectively including Spring Shell dependencies,
don't include that one in.
The follwoing example shows how to exclude `spring-shell-standard-commands`:

====
[source,xml,subs=attributes+]
----
<dependency>
    <groupId>org.springframework.shell</groupId>
    <artifactId>{starter-artifactId}</artifactId>
    <version>{project-version}</version>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.shell</groupId>
            <artifactId>spring-shell-standard-commands</artifactId>
        </exclusion>
    </exclusion>
</dependency>
----
====
=====

[[disabling-specific-commands]]
===== Disabling Specific Commands

To disable a single built-in command, set the `spring.shell.command.<command>.enabled` property to `false` in the application
`Environment`. One way to do so is to pass extra arguments to the Boot application in your `main()` entry point:

====
[source, java]
----
	public static void main(String[] args) throws Exception {
		String[] disabledCommands = {"--spring.shell.command.help.enabled=false"}; // <1>
		String[] fullArgs = StringUtils.concatenateStringArrays(args, disabledCommands);
		SpringApplication.run(MyApp.class, fullArgs);
	}
----
<1> This disables the integrated `help` command
====

===== Overriding Specific Commands

If, instead of disabling a command, you would rather provide your own implementation, then you can either:

* Disable the command as explained <<disabling-specific-commands,earlier>> and have your implementation registered with the same name.
* Have your implementing class implement the `<Command>.Command` interface. As an example, here is how
to override the `clear` command:
+
====
[source, java]
----
public class MyClear implements Clear.Command {

    @ShellMethod("Clear the screen, only better.")
    public void clear() {
        // ...
    }
}
----
====

[NOTE]
.Please Consider Contributing your Changes
====
If you feel like your implementation of a standard command could be valuable to the community,
please open a pull-request at https://github.com/spring-projects/spring-shell.

Alternatively, before making any changes on your own, you can open an issue with the project. Feedback is
always welcome!
====

==== ResultHandlers

TBD

==== PromptProvider
After each command invocation, the shell waits for new input from the user, displaying
a prompt in yellow:

====
[source]
----
shell:>
----
====

It is possible to customize this behavior by registering a bean of type `PromptProvider`.
Such a bean may use internal state to decide what to display to the user (it may, for example,
react to https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#context-functionality-events-annotation[application events])
and can use JLine's `AttributedCharSequence` to display fancy ANSI text.

The following example shows how to use a `PromptProvider`:

====
[source, java]
----
@Component
public class CustomPromptProvider implements PromptProvider {

	private ConnectionDetails connection;

	@Override
	public AttributedString getPrompt() {
		if (connection != null) {
			return new AttributedString(connection.getHost() + ":>",
				AttributedStyle.DEFAULT.foreground(AttributedStyle.YELLOW));
		}
		else {
			return new AttributedString("server-unknown:>",
				AttributedStyle.DEFAULT.foreground(AttributedStyle.RED));
		}
	}

	@EventListener
	public void handle(ConnectionUpdatedEvent event) {
		this.connection = event.getConnectionDetails();
	}
}
----
====

==== Customizing Command Line Options Behavior
Spring Shell comes with two default Spring Boot `ApplicationRunners`:

* `InteractiveShellApplicationRunner` bootstraps the Shell REPL. It sets up the JLine infrastructure and eventually
calls `Shell.run()`
* `ScriptShellApplicationRunner` looks for program arguments that start with `@`, assumes those are local file names and
tries to run commands contained in those files (with the same semantics as the <<script-command,script command>>) and
then exits the process (by effectively disabling the `InteractiveShellApplicationRunner` -- see below).

If this behavior does not suit you, provide at least one bean of type `ApplicationRunner`
and optionally disable the standard ones. You can take inspiration from the `ScriptShellApplicationRunner`:

====
[source,java]
----
include::../../../../spring-shell-core/src/main/java/org/springframework/shell/jline/ScriptShellApplicationRunner.java[tag=documentation]

...
----
====

==== Customizing Arguments Conversion

Conversion from text input to actual method arguments uses the standard Spring
https://docs.spring.io/spring/docs/4.3.11.RELEASE/spring-framework-reference/htmlsingle/#core-convert[conversion] mechanism.
Spring Shell installs a new `DefaultConversionService` (with built-in converters enabled)
and registers to it any bean of type `Converter<S, T>`, `GenericConverter`, or
`ConverterFactory<S, T>` that it finds in the application context.

This means that you can customize conversion to your custom objects
by installing a `Converter<String, Foo>` bean in the context:

====
[source, java]
----
@ShellComponent
class ConversionCommands {

	@ShellMethod("Shows conversion using Spring converter")
	public String conversionExample(DomainObject object) {
		return object.getClass();
	}

}

class DomainObject {
	private final String value;

	DomainObject(String value) {
		this.value = value;
	}

	public String toString() {
		return value;
	}
}

@Component
class CustomDomainConverter implements Converter<String, DomainObject> {

	@Override
	public DomainObject convert(String source) {
		return new DomainObject(source);
	}
}

----
====

[TIP]
.Mind your String representation
=====
As in the preceding example, you should have
your `toString()` implementations return the converse of what was used
to create the object instance. This is because, when a value fails
validation, Spring Shell prints:

====
[source]
----
The following constraints were not met:
	--arg <type> : <message> (You passed '<value.toString()>')
----
====

See <<validating-command-arguments>> for more information.
=====

[NOTE]
====
If you want to customize the `ConversionService` further, you can:

* Have the default one injected in your code and act upon it in some way.
* Override it altogether with your own (custom converters need to be registered by hand).
  The `ConversionService` used by Spring Shell needs to be https://docs.spring.io/spring/docs/4.3.12.RELEASE/spring-framework-reference/htmlsingle/#beans-autowired-annotation-qualifiers[qualified] as `"spring-shell"`.
====

//==== Overriding the JLine Parser

//=== Using Without Spring Boot
