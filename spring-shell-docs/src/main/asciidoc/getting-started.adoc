== Getting Started
To see what Spring Shell has to offer, we can write a trivial shell application that
has a simple command to add two numbers.

=== Writing a Simple Boot Application

Starting with version 2, Spring Shell has been rewritten from the ground up with various
enhancements in mind, one of which is easy integration with Spring Boot.

For the purpose of this tutorial, we create a simple Boot application by
using https://start.spring.io. This minimal application depends only on `spring-boot-starter`
and configures the `spring-boot-maven-plugin` to generate an executable Ã¼ber-jar:

====
[source, xml]
----
...
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
    </dependency>
    ...
</dependencies>
----
====

[[using-spring-shell-add-dependency]]
=== Adding a Dependency on Spring Shell

The easiest way to get going with Spring Shell is to depend on the `{starter-artifactId}` artifact.
This comes with everything you need to use Spring Shell and plays nicely with Boot,
configuring only the necessary beans as needed:

====
[source, xml, subs=attributes+]
----
...
<dependency>
    <groupId>org.springframework.shell</groupId>
    <artifactId>{spring-shell-starter}</artifactId>
    <version>{project-version}</version>
</dependency>
...
----
====

CAUTION: Given that Spring Shell starts the REPL (Read-Eval-Print-Loop) because this dependency is present,
you need to either skip tests when you build (`-DskipTests`) throughout this tutorial or remove the sample integration test
that was generated by https://start.spring.io. If you do not remove it, the integration test creates
the Spring `ApplicationContext` and, depending on your build tool, stays stuck in the eval loop or crashes with a NPE.

[[using-spring-shell-your-first-command]]
=== Your First Command

Now we can add our first command. To do so, create a new class (named whatever you want) and
annotate it with `@ShellComponent` (a variation of `@Component` that is used to restrict
the set of classes that are scanned for candidate commands).

Then we can create an `add` method that takes two ints (`a` and `b`) and returns their sum. We need to annotate it
with `@ShellMethod` and provide a description of the command in the annotation (the only piece of
information that is required):

====
[source, java]
----
package com.example.demo;

import org.springframework.shell.standard.ShellMethod;
import org.springframework.shell.standard.ShellComponent;

@ShellComponent
public class MyCommands {

    @ShellMethod("Add two integers together.")
    public int add(int a, int b) {
        return a + b;
    }
}
----
====

[[using-spring-shell-try-application]]
=== Trying the Application

To build the application and run the generated jar, run the following command:

====
[source, bash]
----
./mvnw clean install -DskipTests
[...]

java -jar target/demo-0.0.1-SNAPSHOT.jar
----
====

You are greeted by the following screen (the banner comes from Spring Boot and can be
https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-banner[customized]:

====
[source]
----
shell:>
----
====

A yellow `shell:>` prompt invites you to type commands. Type `add 1 2`, press `ENTER`, and admire the magic:

====
[source, bash]
----
shell:>add 1 2
3
----
====

You should play with the shell (hint: there is a `help` command). When you are done, type `exit` and press `ENTER`.

The rest of this document delves deeper into the whole Spring Shell programming model.
